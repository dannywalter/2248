<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>2248 Style Game with Improved Gravity Animation</title>
    <style>
        body {
            background-color: #2c2c2c;
            color: #f9f9f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        /* New container to limit game size */
        .game-container {
            width: 100%;
            max-width: 500px;
            height: 100%;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
        }

        #preview-display {
            min-height: 30px; 
            line-height: 30px;
            visibility: hidden; /* Hidden when no preview */
            transition: opacity 0.3s;
            margin-bottom: 5px;
        }

        .score-display {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .moves-display {
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 10px;
}

        #game-board {
            position: relative;
            background-color: #444;
            border-radius: 8px;
            user-select: none;
            width: 100%;
            flex-grow: 1;
            margin: 0;
            overflow: hidden;
        }

        .game-cell {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            /* Initially no transition, we will add it dynamically */
        }

        .game-cell.highlight {
            border: 2px solid #ffffff;
        }

        .game-cell.merging {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .merged-highlight {
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="preview-display"></div>
<div class="score-display">Score: <span id="score-value">0</span></div>
<div class="moves-display">Moves: <span id="moves-value">25</span></div>
        <div id="game-board"></div>
    </div>
    <script>
        const rows = 8;
        const cols = 5;
        let score = 0;

let movesLeft = 25; // Number of moves before game over
let gameActive = true;
let highestValue = 0; // Track highest doodle rarity achieved

        let board = Array.from({ length: rows }, () => Array(cols).fill(null));
        let isDragging = false;
        let dragChain = [];
        let startCell = null;
        let selectedCells = new Set();
        let TILE_SIZE, TILE_GAP;

        let previewCumulativeValueState = null;
        let previewBaseValue = null;
        let previewIdenticalChainLengthState = 1;
        let previewInitialIdenticalMet = false;

        const chainThresholds = [2, 3, 5, 9, 17];

        const gameBoard = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score-value');
        const previewDisplay = document.getElementById('preview-display');

        let cellElements = new Map(); // key: "r,c", value: DOM element

        function calculateTileSize() {
            // Get available board dimensions
            const boardRect = gameBoard.getBoundingClientRect();
            const boardWidth = boardRect.width;
            const boardHeight = boardRect.height;
            
            // Calculate tile size to fit the board
            const gapCount = { 
                horizontal: cols - 1,
                vertical: rows - 1
            };
            
            // Calculate based on width
            const tileWidthBased = (boardWidth - (gapCount.horizontal * 4)) / cols;
            // Calculate based on height
            const tileHeightBased = (boardHeight - (gapCount.vertical * 4)) / rows;
            
            // Use the smaller dimension to ensure tiles fit
            TILE_SIZE = Math.floor(Math.min(tileWidthBased, tileHeightBased));
            TILE_GAP = 4;
            
            // Adjust font size based on tile size
            const baseFontSize = 24;
            const fontScale = TILE_SIZE / 80; // 80 was the original tile size
            document.documentElement.style.setProperty('--tile-font-size', `${Math.max(14, Math.floor(baseFontSize * fontScale))}px`);
        }

        function init() {
            calculateTileSize();
            board = Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => getRandomTileValue())
            );
            renderBoard();
            
            // Recalculate on resize
            window.addEventListener('resize', () => {
                calculateTileSize();
                renderBoard();
            });
        }

        function getRandomTileValue() {
            const values = [2, 4, 8, 16, 32];
            return values[Math.floor(Math.random() * values.length)];
        }

        function getTileColor(value) {
            if (!value) return '#ccc0b3';
            const hue = (Math.log2(value) * 40) % 360;
            const lightness = 50 - Math.min(Math.log2(value), 10);
            return `hsl(${hue}, 70%, ${lightness}%)`;
        }

        function positionForCell(r, c) {
            const top = r * (TILE_SIZE + TILE_GAP);
            const left = c * (TILE_SIZE + TILE_GAP);
            return {top, left};
        }

        function renderBoard() {
            scoreDisplay.textContent = score;

            // Phase 1: Place all tiles at their final positions instantly (no transition)
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const value = board[r][c];
                    const key = `${r},${c}`;
                    let cellEl = cellElements.get(key);

                    if (value === null) {
                        if (cellEl) {
                            cellEl.remove();
                            cellElements.delete(key);
                        }
                        continue;
                    }

                    if (!cellEl) {
                        cellEl = document.createElement('div');
                        cellEl.classList.add('game-cell');
                        cellEl.dataset.row = r;
                        cellEl.dataset.col = c;
                        gameBoard.appendChild(cellEl);
                        cellElements.set(key, cellEl);
                    }

                    cellEl.textContent = value;
                    cellEl.style.backgroundColor = getTileColor(value);
                    cellEl.style.width = TILE_SIZE + 'px';
                    cellEl.style.height = TILE_SIZE + 'px';
                    cellEl.style.fontSize = `var(--tile-font-size)`;
                    
                    const pos = positionForCell(r, c);

                    // No transition yet
                    cellEl.style.transition = 'none';
                    // Place them directly at final position
                    cellEl.style.top = pos.top + 'px';
                    cellEl.style.left = pos.left + 'px';

                    cellEl.classList.remove('highlight','merged-highlight','merging');
                }
            }

            // Force reflow to apply these positions
            gameBoard.offsetHeight; // reflow

            // Phase 2: Now apply transitions and move them UP by 50px
            cellElements.forEach((cellEl, key) => {
                cellEl.style.transition = 'top 0.5s ease, left 0.5s ease, transform 0.5s ease, opacity 0.3s ease';
                const {row, col} = getCellPosition(cellEl);
                if (row !== null && col !== null) {
                    const pos = positionForCell(row, col);
                    cellEl.style.top = (pos.top - 50) + 'px';
                }
            });

            // Phase 3: Next frame, move them down to their final position to create the sliding effect
            requestAnimationFrame(() => {
                cellElements.forEach((cellEl, key) => {
                    const {row, col} = getCellPosition(cellEl);
                    if (row !== null && col !== null) {
                        const pos = positionForCell(row, col);
                        cellEl.style.top = pos.top + 'px';
                    }
                });
            });
        }

        function isThreshold(length) {
            return chainThresholds.includes(length);
        }

        function animateChainMerge(chain, finalValue) {
            const finalCell = chain[chain.length - 1];
            const finalKey = `${finalCell.row},${finalCell.col}`;

            // Fade out intermediate tiles
            for (let i = 0; i < chain.length - 1; i++) {
                const {row, col} = chain[i];
                const key = `${row},${col}`;
                const el = cellElements.get(key);
                if (el) {
                    el.classList.add('merging');
                }
            }

            setTimeout(() => {
                // Remove intermediate tiles
                for (let i = 0; i < chain.length - 1; i++) {
                    const {row, col} = chain[i];
                    const key = `${row},${col}`;
                    const el = cellElements.get(key);
                    if (el) {
                        el.remove();
                        cellElements.delete(key);
                    }
                    board[row][col] = null;
                }

                // Update final tile
                board[finalCell.row][finalCell.col] = finalValue;

                applyGravity();
                refillBoard();
                renderBoard(); // This will cause the sliding animation again

                // Highlight final cell
                const finalEl = cellElements.get(finalKey);
                if (finalEl) {
                    finalEl.classList.add('merged-highlight');
                }
            }, 300);
        }

        // Rest of your existing functions - applyGravity, refillBoard, processChain, etc.
        function applyGravity() {
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = rows - 1; r >= 0; r--) {
                    if (board[r][c] !== null) {
                        stack.push(board[r][c]);
                    }
                }
                for (let r = rows - 1; r >= 0; r--) {
                    board[r][c] = stack.length > 0 ? stack.shift() : null;
                }
            }
        }

        function refillBoard() {
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows; r++) {
                    if (board[r][c] === null) {
                        board[r][c] = getRandomTileValue();
                    }
                }
            }
        }

        function processChain(chain) {
            if (chain.length < 2) return;

            let { row: startRow, col: startCol } = chain[0];
            let firstValue = board[startRow][startCol];

            let cumulativeValue = firstValue;
            let baseValue = firstValue;
            let identicalChainLength = 1;
            let initialIdenticalMet = false;
            let chainValid = true;

            for (let i = 1; i < chain.length; i++) {
                const { row, col } = chain[i];
                const currentValue = board[row][col];

                let result = applyChainRules(cumulativeValue, baseValue, identicalChainLength, initialIdenticalMet, currentValue);
                if (result.valid) {
                    ({ 
                        cumulativeValue, 
                        baseValue,
                        identicalChainLength, 
                        initialIdenticalMet
                    } = result);

                    score += currentValue;
                } else {
                    chainValid = false;
                    break;
                }
            }

            if (chainValid) {
        animateChainMerge(chain, cumulativeValue);
        
        // Update highest value achieved
        if (cumulativeValue > highestValue) {
            highestValue = cumulativeValue;
        }
    }
        }

        function applyChainRules(cV, bV, iCL, iIM, newValue) {
            // Identical check
            if (newValue === bV) {
                iCL++;
                if (isThreshold(iCL)) {
                    cV *= 2;
                }
                if (iCL >= 2) {
                    iIM = true;
                }
                return {valid: true, cumulativeValue: cV, baseValue: bV, identicalChainLength: iCL, initialIdenticalMet: iIM};
            }

            // Progressive step
            if (iIM && newValue === bV * 2) {
                cV *= 2;
                bV = bV * 2;
                iCL = 1;
                return {valid: true, cumulativeValue: cV, baseValue: bV, identicalChainLength: iCL, initialIdenticalMet: iIM};
            }

            return {valid: false};
        }

        function resetDrag() {
            isDragging = false;
            startCell = null;
            dragChain.forEach(cell => {
                const key = `${cell.row},${cell.col}`;
                const el = cellElements.get(key);
                if (el) {
                    el.classList.remove('highlight');
                }
            });
            dragChain = [];
            selectedCells.clear();
        }

        function resetPreview() {
            previewCumulativeValueState = null;
            previewBaseValue = null;
            previewIdenticalChainLengthState = 1;
            previewInitialIdenticalMet = false;
            previewDisplay.textContent = '';
            previewDisplay.style.visibility = 'hidden';
        }

        function updatePreview() {
            if (previewCumulativeValueState !== null) {
                previewDisplay.textContent = `Preview: ${previewCumulativeValueState}`;
                previewDisplay.style.visibility = 'visible';
            } else {
                previewDisplay.textContent = '';
                previewDisplay.style.visibility = 'hidden';
            }
        }

        function isValidMove(currentCell) {
            if (!startCell || !currentCell) return false;
            if (dragChain.length === 0) return false;

            const lastCell = dragChain[dragChain.length - 1];
            if (!lastCell) return false;

            const { row: lastRow, col: lastCol } = lastCell;
            const { row: currentRow, col: currentCol } = currentCell;

            const cellKey = `${currentRow},${currentCol}`;
            if (selectedCells.has(cellKey)) return false;

            const isAdjacent =
                Math.abs(currentRow - lastRow) <= 1 &&
                Math.abs(currentCol - lastCol) <= 1 &&
                (currentRow !== lastRow || currentCol !== lastCol);

            const currentTileValue = board[currentRow][currentCol];

            const result = simulateAddTile(
                previewCumulativeValueState,
                previewBaseValue,
                previewIdenticalChainLengthState,
                previewInitialIdenticalMet,
                currentTileValue
            );

            return isAdjacent && result.valid;
        }

        function simulateAddTile(cV, bV, iCL, iIM, newValue) {
            if (cV === null) {
                cV = newValue;
                bV = newValue;
                iCL = 1;
                iIM = false;
                return {valid:true, cV, bV, iCL, iIM};
            }

            if (newValue === bV) {
                iCL++;
                if (isThreshold(iCL)) {
                    cV *= 2;
                }
                if (iCL >= 2) iIM = true;
                return {valid:true, cV, bV, iCL, iIM};
            }

            if (iIM && newValue === bV * 2) {
                cV *= 2;
                bV = bV * 2;
                iCL = 1;
                return {valid:true, cV, bV, iCL, iIM};
            }

            return {valid:false};
        }

        function handleStart(e) {
            const target = e.target;
            const cell = target.closest('.game-cell');
            if (!cell) return;

            const position = getCellPosition(cell);
            if (!position) return;

            isDragging = true;
            startCell = position;
            const startValue = board[position.row][position.col];
            previewCumulativeValueState = startValue;
            previewBaseValue = startValue;
            previewIdenticalChainLengthState = 1;
            previewInitialIdenticalMet = false;

            dragChain = [position];
            const key = `${position.row},${position.col}`;
            selectedCells = new Set();
            selectedCells.add(key);

            const startEl = cellElements.get(key);
            if (startEl) startEl.classList.add('highlight');

            updatePreview();
        }

        function handleMove(e) {
    if (!isDragging) return;
    if (dragChain.length === 0) return;

    const target = e.target;
    const cell = target.closest('.game-cell');
    if (!cell) return;

    const currentCell = getCellPosition(cell);
    if (!currentCell) return;

    const cellKey = `${currentCell.row},${currentCell.col}`;
    
    // Check if we're going back to the second-last cell (backtracking)
    if (dragChain.length > 1) {
        const secondLastCell = dragChain[dragChain.length - 2];
        if (secondLastCell.row === currentCell.row && secondLastCell.col === currentCell.col) {
            // Get the last cell to remove its highlighting
            const lastCell = dragChain[dragChain.length - 1];
            const lastCellKey = `${lastCell.row},${lastCell.col}`;
            
            // Remove last cell from chain
            dragChain.pop();
            selectedCells.delete(lastCellKey);
            
            // Remove highlight from the removed cell
            const lastEl = cellElements.get(lastCellKey);
            if (lastEl) lastEl.classList.remove('highlight');
            
            // Recalculate preview values based on the new chain
            recalculatePreviewValues();
            updatePreview();
            
            return;
        }
    }

    // If not backtracking, handle as before (adding new cells)
    if (selectedCells.has(cellKey)) return;

    if (isValidMove(currentCell)) {
        const lastCell = dragChain[dragChain.length - 1];
        if (lastCell && (lastCell.row !== currentCell.row || lastCell.col !== currentCell.col)) {
            dragChain.push(currentCell);
            selectedCells.add(cellKey);

            const currentValue = board[currentCell.row][currentCell.col];
            const simResult = simulateAddTile(
                previewCumulativeValueState,
                previewBaseValue,
                previewIdenticalChainLengthState,
                previewInitialIdenticalMet,
                currentValue
            );

            if (simResult.valid) {
                previewCumulativeValueState = simResult.cV;
                previewBaseValue = simResult.bV;
                previewIdenticalChainLengthState = simResult.iCL;
                previewInitialIdenticalMet = simResult.iIM;
            }

            const el = cellElements.get(cellKey);
            if (el) el.classList.add('highlight');

            updatePreview();
        }
    }
}

// Add this new function to recalculate preview values when backtracking
function recalculatePreviewValues() {
    // Reset preview values
    previewCumulativeValueState = null;
    previewBaseValue = null;
    previewIdenticalChainLengthState = 1;
    previewInitialIdenticalMet = false;

    // Rebuild preview values from the current chain
    for (let i = 0; i < dragChain.length; i++) {
        const {row, col} = dragChain[i];
        const tileValue = board[row][col];
        
        const result = simulateAddTile(
            previewCumulativeValueState,
            previewBaseValue,
            previewIdenticalChainLengthState,
            previewInitialIdenticalMet,
            tileValue
        );
        
        if (result.valid) {
            previewCumulativeValueState = result.cV;
            previewBaseValue = result.bV;
            previewIdenticalChainLengthState = result.iCL;
            previewInitialIdenticalMet = result.iIM;
        }
    }
}

function handleEnd() {
    if (!gameActive) return;
    
    if (isDragging && dragChain.length > 1) {
        processChain(dragChain);
        
        // Decrement moves and check for game over
        movesLeft--;
        document.getElementById('moves-value').textContent = movesLeft;
        
        if (movesLeft <= 0) {
            gameActive = false;
            // No custom screen - will be replaced by Farcade SDK
            console.log("GAME OVER - Highest value: " + highestValue);
            // This is where Farcade game over would be triggered
        }
    }
    resetDrag();
    resetPreview();
}

        function getCellPosition(element) {
            if (!element || !element.dataset) return null;
            const row = parseInt(element.dataset.row, 10);
            const col = parseInt(element.dataset.col, 10);
            if (isNaN(row) || isNaN(col)) return null;
            return { row, col };
        }

        gameBoard.addEventListener("mousedown", handleStart);
        gameBoard.addEventListener("mousemove", handleMove);
        gameBoard.addEventListener("mouseup", handleEnd);

        gameBoard.addEventListener("touchstart", e => {
            if (e.touches.length > 0) {
                handleStart(e.touches[0]);
                e.preventDefault();
            }
        });

        gameBoard.addEventListener("touchmove", e => {
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                // Get element at touch coordinates instead of relying on e.target
                const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Create a synthetic event with the correct target
                const syntheticEvent = {
                    target: elementAtPoint
                };
                
                handleMove(syntheticEvent);
                e.preventDefault();
            }
        });

        gameBoard.addEventListener("touchend", e => {
            handleEnd();
            e.preventDefault();
        });

        init();

        function restartGame() {
    movesLeft = 25;
    gameActive = true;
    highestValue = 0;
    score = 0;
    document.getElementById('score-value').textContent = score;
    document.getElementById('moves-value').textContent = movesLeft;
    init();
}

// Add a key event listener to restart with 'R' key
document.addEventListener('keydown', function(event) {
    if (event.key === 'r' || event.key === 'R') {
        restartGame();
    }
});
    </script>
</body>
</html>