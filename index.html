<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>2248 Style Game with Improved Gravity Animation</title>
    <style>
      html,
      body {
        position: fixed;
        overflow: hidden;
        width: 100%;
        height: 100%;
        overscroll-behavior: none; /* Prevent pull to refresh */
        touch-action: none; /* Disable browser handling of all touch gestures */
      }

      body {
        background-color: #191919;
        color: #f9f9f9;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        font-family: Arial, sans-serif;
        -webkit-touch-callout: none; /* Prevent callout on long-press */
        -webkit-user-select: none; /* Safari */
        -khtml-user-select: none; /* Konqueror */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE/Edge */
        user-select: none; /* Standard */
      }

      /* New container to limit game size */
      .game-container {
        width: 100%;
        max-width: 500px;
        height: 100%;
        max-height: 800px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        box-sizing: border-box;
        overflow: hidden;
      }

      /* Game header styling */
      .game-header {
  width: 100%;
  padding: 0px;
  margin-bottom: 5px;
  display: flex;
  flex-direction: column;
  align-items: center;
  box-sizing: border-box;
  gap: 5px;
}

.logo-container {
  width: 60%;
  display: flex;
  justify-content: center;
  margin-bottom: 0px;
}

.game-logo {
  max-width: 80%;
  height: auto;
  margin: 0 auto;
}

.stats-row {
  width: 50%;
  display: flex;
  justify-content: space-between;
  gap: 15px;
}

.stat-box {
  flex: 1;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 8px;
  padding: 0px;
  text-align: center;
}

.stat-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #999;
  margin-bottom: 0px;
}

.stat-value {
  font-size: 14px;
  font-weight: bold;
  color: white;
}

#preview-display {
  width: 50%;
  min-height: 30px;
  padding: 0px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-sizing: border-box;
  font-size: 12px; /* Smaller font size for all text in preview */
  color: rgba(255, 255, 255, 0.9);
  visibility: visible !important; /* Ensure visibility */
}

.preview-img {
  height: 26px;
  width: 26px;
  object-fit: contain;
  vertical-align: middle;
  border-radius: 5px;
}
      
      /* We can remove these old styles */
      .score-display,
      .moves-display {
        display: none;
      }

      #game-board {
        position: relative;
        user-select: none;
        width: 100%;
        flex-grow: 1;
        margin: 0;
        touch-action: manipulation;
      }

      .game-cell {
        position: absolute;
        background-size: cover;
        background-position: center;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 4px;
        font-size: 24px;
        font-weight: bold;
        color: #333;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .game-cell img {
        max-width: 90%;
        max-height: 90%;
        object-fit: contain;
        -webkit-user-drag: none;
        user-select: none;
        pointer-events: none; /* This is key to make events pass through to parent */
        draggable: false;
      }

      .game-cell.highlight {
        border: 2px solid #ffffff;
      }

      .game-cell.merging {
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .merged-highlight {
        animation: pulse 0.5s;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
  </head>
  <body>
    <div class="game-container">
  <div class="game-header">
    <div class="logo-container">
      <img src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/dooplicates-logo-white-8bsxymm2CNmvF9d7518d7ohzoyfh9W.png" alt="Dooplicates" class="game-logo">
    </div>
    <div class="stats-row">
      <div class="stat-box score-box">
        <div class="stat-label">SCORE</div>
        <div class="stat-value" id="score-value">0</div>
      </div>
      <div class="stat-box moves-box">
        <div class="stat-label">MOVES</div>
        <div class="stat-value" id="moves-value">25</div>
      </div>
    </div>
    <div id="preview-display"></div>
  </div>
  <div id="game-board"></div>
</div>
    <script>
      const rows = 6;
      const cols = 4;
      let score = 0;

      let movesLeft = 25; // Number of moves before game over
      let gameActive = true;
      let highestValue = 0; // Track highest doodle rarity achieved

      // Add Farcade SDK event listeners
      if (window.FarcadeSDK) {
  window.FarcadeSDK.on('play_again', () => {
    restartGame();
  });

  window.FarcadeSDK.on('toggle_mute', (data) => {
    console.log("Mute state changed:", data.isMuted);
    // Update sound manager mute state
    if (SoundManager.isInitialized) {
      SoundManager.setMute(data.isMuted);
    }
  });
}

      let board = Array.from({ length: rows }, () => Array(cols).fill(null));
      let isDragging = false;
      let dragChain = [];
      let startCell = null;
      let selectedCells = new Set();
      let TILE_SIZE, TILE_GAP;

      let achievedValues = new Set(); // Track which values player has unlocked

      let previewCumulativeValueState = null;
      let previewBaseValue = null;
      let previewIdenticalChainLengthState = 1;
      let previewInitialIdenticalMet = false;

      const chainThresholds = [2, 3, 5, 9, 17];

      const gameBoard = document.getElementById("game-board");
      const scoreDisplay = document.getElementById("score-value");
      const previewDisplay = document.getElementById("preview-display");
      const movesDisplay = document.getElementById("moves-value");

      let cellElements = new Map(); // key: "r,c", value: DOM element
      const animatingPositions = new Set(); // Tracks keys of cells currently animating their position

      const DROP_ANIMATION_DURATION = "0.3s";
      const DROP_ANIMATION_EASING = "ease-out";

      // Image configuration
      const preloadedImages = {
  2: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/doopie%2001-rrQis0SMYhgPEDDTdfd49PrpG9ydQm.png",
    img: null,
  },
  4: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/doopie%2006-p8BT3LdevafiK2IeV8jcET1cpvAN5W.png",
    img: null,
  },
  8: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/doopie%2005-yfrCmJWS34YqOAJTy9awEcFYwE9dZl.png",
    img: null,
  },
  16: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/doopie%2003-TpUBhs6a8xAt96uAmJFNG9TswmvyS0.png",
    img: null,
  },
  32: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/doopie%2007-av09W8BO3HVkTmOVHUD88WRHzg5cZ8.png",
    img: null,
  },
  64: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/doopie%2002-yrMROul6peKpWfdDU3whhDTkTilpke.png",
    img: null,
  },
  128: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/doopie%2004-REUUG9cMXkIp3yOng0bK4oEUXZqN4E.png",
    img: null,
  },
  256: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/1735793845894-AngryCoffee-VTcFJq9poQu997zZKEd3kjasMQHT2q.png",
    img: null,
  },
  512: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/1735793846569-Coffee-LpuCY26zFqFngC43yOjAtK3Fs8JCsC.png",
    img: null,
  },
  1024: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/1735793846563-IceCream-VqhaB84fa9AyT4cMrc8sMNfYYTKYnC.png",
    img: null,
  },
  2048: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/1735793846541-Popsicle-1mWavbKDINK4HC8Gr80h1Z73WPXxlT.png",
    img: null,
  },
  4096: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/1735793846573-Donkey-RO0SwGPRJAH36SGDBx856lwsYQSDfj.png",
    img: null,
  },
  8192: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/1735793846569-Poop-yLRaAiPj1HX4cfgpCtQIJSG2zehVqc.png",
    img: null,
  },
  16384: {
    src: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/1735793899155-Bree_PeaceLove_Sticker1-01-dB0T85oIY3KJfbtE3FhuH0MS8vujJw.png",
    img: null,
  }
};

// Sound system
const SoundManager = {
  sounds: {
    bubble: null,
    merge: null
  },
  audioContext: null,
  isMuted: false,
  gainNode: null,
  isInitialized: false,
  
  // Initialize audio on first user interaction
  init() {
    if (this.isInitialized) return;
    
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.gainNode = this.audioContext.createGain();
      this.gainNode.connect(this.audioContext.destination);
      this.loadSounds();
      this.isInitialized = true;
      
      // Apply mute state from Farcade if available
      if (window.FarcadeSDK && window.FarcadeSDK._isMuted) {
        this.setMute(true);
      }
    } catch (e) {
      console.error("Web Audio API not supported:", e);
    }
  },
  
  // Load all sound assets
  loadSounds() {
    // Load bubble sound with your provided URL
    this.loadSound("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/water-drop-cut-Gh9JOaPkNa3hhf3IwHcWiDK3Tg5rsv.mp3")
      .then(buffer => this.sounds.bubble = buffer)
      .catch(e => console.warn("Failed to load bubble sound", e));
      
    // Load pop/merge sound with your provided URL
    this.loadSound("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/f781d46e-5da6-4e58-95ac-e984443cfbff/bubble-pop-cut-8nhjPeMO2tjo3gXeY5e1Hr54ySh1ep.mp3")
      .then(buffer => this.sounds.merge = buffer)
      .catch(e => console.warn("Failed to load merge sound", e));
  },
  
  // Fetch and decode a single sound
  async loadSound(url) {
    try {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      return await this.audioContext.decodeAudioData(arrayBuffer);
    } catch (e) {
      console.error(`Error loading sound: ${url}`, e);
      return null;
    }
  },
  
  // Play bubble sound with pitch based on chain length
  playBubbleSound(chainLength) {
    if (!this.isInitialized || this.isMuted || !this.sounds.bubble) return;
    
    // Resume audio context if suspended
    if (this.audioContext.state === 'suspended') {
      this.audioContext.resume();
    }
    
    const source = this.audioContext.createBufferSource();
    source.buffer = this.sounds.bubble;
    
    // Increase pitch with chain length
    const basePitch = 0.8;
    const pitchIncrement = 0.1;
    source.playbackRate.value = basePitch + (chainLength * pitchIncrement);
    
    // Set volume
    const gainNode = this.audioContext.createGain();
    gainNode.gain.value = 0.4; // Adjust volume as needed
    
    source.connect(gainNode);
    gainNode.connect(this.gainNode);
    source.start(0);
  },
  
  // Play merge pop sound
  playMergeSound(chainLength) {
    if (!this.isInitialized || this.isMuted || !this.sounds.merge) return;
    
    // Resume audio context if suspended
    if (this.audioContext.state === 'suspended') {
      this.audioContext.resume();
    }
    
    const source = this.audioContext.createBufferSource();
    source.buffer = this.sounds.merge;
    
    // Adjust based on chain length
    const volume = Math.min(0.3 + (chainLength * 0.05), 0.9);
    const pitch = Math.min(1 + (chainLength * 0.05), 1.5);
    
    source.playbackRate.value = pitch;
    
    const gainNode = this.audioContext.createGain();
    gainNode.gain.value = volume;
    
    source.connect(gainNode);
    gainNode.connect(this.gainNode);
    source.start(0);
  },
  
  // Set mute state
  setMute(isMuted) {
    this.isMuted = isMuted;
    if (this.gainNode) {
      this.gainNode.gain.value = isMuted ? 0 : 1;
    }
  }
};

      const imageValues = Object.keys(preloadedImages).map(Number); // e.g., [2, 4]

      function preloadAllImages() {
        const imagePromises = imageValues.map((value) => {
          return new Promise((resolve, reject) => {
            const PImage = new Image();
            PImage.src = preloadedImages[value].src;
            PImage.onload = () => {
              preloadedImages[value].img = PImage;
              resolve();
            };
            PImage.onerror = () => {
              console.error(`Failed to load image for value ${value}: ${preloadedImages[value].src}`);
              reject(new Error(`Failed to load image for ${value}`));
            };
          });
        });
        return Promise.all(imagePromises);
      }

      function getPreloadedImageSrc(value) {
        if (preloadedImages[value] && preloadedImages[value].img) {
          return preloadedImages[value].img.src;
        }
        console.warn(`No preloaded image found for value: ${value}`);
        return ""; // Fallback
      }

      function calculateTileSize() {
        const boardRect = gameBoard.getBoundingClientRect();
        const boardWidth = boardRect.width;
        const boardHeight = boardRect.height;

        const gapCount = {
          horizontal: cols - 1,
          vertical: rows - 1,
        };

        const tileWidthBased = (boardWidth - gapCount.horizontal * 4) / cols;
        const tileHeightBased = (boardHeight - gapCount.vertical * 4) / rows;

        TILE_SIZE = Math.floor(Math.min(tileWidthBased, tileHeightBased));
        TILE_GAP = 4;

        const baseFontSize = 24;
        const fontScale = TILE_SIZE / 80;
        document.documentElement.style.setProperty(
          "--tile-font-size",
          `${Math.max(14, Math.floor(baseFontSize * fontScale))}px`,
        );
      }

      function initGameLogic() {
  // Renamed from init to be called after preloading
  calculateTileSize();
  board = Array.from({ length: rows }, () => Array(cols).fill(null));

  // Generate 2-3 positions for value 8 tiles that are far apart
  const eightPositions = [];
  const numEights = Math.floor(Math.random() * 2) + 2; // 2-3 eights
  
  // Place 8s first to ensure they're distributed well
  while (eightPositions.length < numEights) {
    const r = Math.floor(Math.random() * rows);
    const c = Math.floor(Math.random() * cols);
    
    // Check if this position is far enough from existing 8s
    let isFarEnough = true;
    for (const pos of eightPositions) {
      // Manhattan distance - ensure at least 3 cells apart
      const distance = Math.abs(pos.row - r) + Math.abs(pos.col - c);
      if (distance < 3) {
        isFarEnough = false;
        break;
      }
    }
    
    if (isFarEnough) {
      eightPositions.push({ row: r, col: c });
    }
  }

        const initialCells = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      // Is this one of our designated 8 positions?
      const isEightPosition = eightPositions.some(pos => pos.row === r && pos.col === c);
      
      // Assign value: 8 for special positions, otherwise 2 or 4
      const val = isEightPosition ? 8 : (Math.random() < 0.6 ? 2 : 4);
      board[r][c] = val;
      initialCells.push({ row: r, col: c, value: val });
    }
  }

        gameBoard.innerHTML = "";
        cellElements.clear();
        animatingPositions.clear();

        renderBoard(true, [], initialCells); // isInitialLayout = true

        if (window.resizeListener) {
          window.removeEventListener("resize", window.resizeListener);
        }
        window.resizeListener = () => {
          calculateTileSize();
          const currentBoardCells = [];
          for (let r_idx = 0; r_idx < rows; r_idx++) {
            for (let c_idx = 0; c_idx < cols; c_idx++) {
              if (board[r_idx][c_idx] !== null) {
                currentBoardCells.push({ row: r_idx, col: c_idx, value: board[r_idx][c_idx] });
              }
            }
          }
          gameBoard.innerHTML = "";
          cellElements.clear();
          animatingPositions.clear();
          renderBoard(true, [], currentBoardCells);
        };
        window.addEventListener("resize", window.resizeListener);
      }

      // Update this function (though it's not used directly)
function getRandomTileValue() {
  const values = [2, 4, 8];
  return values[Math.floor(Math.random() * values.length)];
}

      // New function specifically for initial board generation
function getInitialBoardTileValue() {
  // For refills during gameplay, use mostly lower values
  return Math.random() < 0.7 ? 2 : 4;
}

      function getTileColor(value) {
        if (!value) return "#444";
        /* if (imageValues.includes(value)) {
          // If it's a tile that will have an image
          return "transparent"; // Or a very subtle common background
        } */
        const colorMap = {
          2: "#74ABFE", 
          4: "#5E90FF",
          8: "#A1E9FF",
          16: "#69DCFF",
          32: "#C0C0FF",
          64: "#A4A4F4",
          128: "#FFADDE",
          256: "#FF7BD7",
          512: "#FFC897",
          1024: "#FFAC99",
          2048: "#FFE780",
          4096: "#FFC897",
          8192: "#71FFB8",
          16384: "#53EACD",
        };
        if (!colorMap[value]) {
          const baseColor = colorMap[16384] || "#333"; // Fallback for ultra high
          return `linear-gradient(135deg, ${baseColor} 0%, white 100%)`;
        }
        return colorMap[value] || "#ffffff";
      }

      function positionForCell(r, c) {
  // Calculate the total width and height of the grid
  const gridWidth = cols * TILE_SIZE + (cols - 1) * TILE_GAP;
  const gridHeight = rows * TILE_SIZE + (rows - 1) * TILE_GAP;
  
  // Calculate the offset to center the grid in the game board
  const boardRect = gameBoard.getBoundingClientRect();
  const offsetLeft = Math.max(0, (boardRect.width - gridWidth) / 2);
  const offsetTop = Math.max(0, (boardRect.height - gridHeight) / 2);
  
  // Calculate position with offset
  const top = offsetTop + r * (TILE_SIZE + TILE_GAP);
  const left = offsetLeft + c * (TILE_SIZE + TILE_GAP);
  
  return { top, left };
}

      function updateCellElementContent(cellEl, value) {
        const newValueStr = String(value);
        const oldValueStr = cellEl.dataset.currentValue;

        const newIsImage = imageValues.includes(value);
        const oldIsImage = imageValues.includes(oldValueStr ? parseInt(oldValueStr, 10) : NaN);

        // If value and type (image/text) haven't changed, and if it's an image, the alt tag confirms it's the correct one.
        if (oldValueStr === newValueStr && newIsImage === oldIsImage) {
          if (newIsImage) {
            const img = cellEl.querySelector("img");
            if (img && img.alt === newValueStr && img.src === getPreloadedImageSrc(value)) {
              // Also check src
              return; // Image is already correct
            }
          } else {
            return; // Text is already correct
          }
        }

        cellEl.dataset.currentValue = newValueStr; // Update stored value

        if (newIsImage) {
          cellEl.textContent = ""; // Clear any previous number text
          let img = cellEl.querySelector("img");
          const targetSrc = getPreloadedImageSrc(value);

          if (!img) {
            // No image element exists, create it
            img = document.createElement("img");
            img.src = targetSrc; // Set src BEFORE append for preloaded images
            img.alt = newValueStr;
            cellEl.appendChild(img);
          } else {
            // Image element exists, update its src and alt if they are different
            if (img.alt !== newValueStr || img.src !== targetSrc) {
              img.src = targetSrc;
              img.alt = newValueStr;
            }
          }
        } else {
          // New value is a number, not an image
          cellEl.textContent = newValueStr;
          const img = cellEl.querySelector("img");
          if (img) {
            // If an image element exists from a previous state, remove it
            img.remove();
          }
        }
      }

      function createStaticCell(r, c, value) {
        // Not changed, but uses updated updateCellElementContent
        const key = `${r},${c}`;
        let cellEl = document.createElement("div");
        cellEl.classList.add("game-cell");
        cellEl.dataset.row = r;
        cellEl.dataset.col = c;

        updateCellElementContent(cellEl, value);
        cellEl.style.background = getTileColor(value);
        cellEl.style.width = TILE_SIZE + "px";
        cellEl.style.height = TILE_SIZE + "px";
        cellEl.style.fontSize = `var(--tile-font-size)`;

        const pos = positionForCell(r, c);
        cellEl.style.transition = "none";
        cellEl.style.top = pos.top + "px";
        cellEl.style.left = pos.left + "px";
        cellEl.style.opacity = "1";

        gameBoard.appendChild(cellEl);
        cellElements.set(key, cellEl);
        return cellEl;
      }

      function renderBoard(isInitialLayout = false, droppedCells = [], newlyAddedCells = [], mergeTargetKey = null) {
        scoreDisplay.textContent = score;
        movesDisplay.textContent = movesLeft;
        
        const processedDomKeys = new Set();

        if (isInitialLayout) {
          newlyAddedCells.forEach(({ row, col, value }) => {
            const key = `${row},${col}`;
            let cellEl = document.createElement("div");
            cellEl.classList.add("game-cell");
            cellEl.dataset.row = row;
            cellEl.dataset.col = col;

            updateCellElementContent(cellEl, value); // Set content first
            cellEl.style.background = getTileColor(value);
            cellEl.style.width = TILE_SIZE + "px";
            cellEl.style.height = TILE_SIZE + "px";
            cellEl.style.fontSize = `var(--tile-font-size)`;

            const finalPos = positionForCell(row, col);
            cellEl.style.transition = "none";
            cellEl.style.top = finalPos.top - 50 + "px";
            cellEl.style.left = finalPos.left + "px";
            cellEl.style.opacity = "1";

            gameBoard.appendChild(cellEl);
            cellElements.set(key, cellEl);
            processedDomKeys.add(key);
          });

          gameBoard.offsetHeight;

          requestAnimationFrame(() => {
            processedDomKeys.forEach((key) => {
              const cellEl = cellElements.get(key);
              if (cellEl) {
                const r = parseInt(cellEl.dataset.row);
                const c = parseInt(cellEl.dataset.col);
                const finalPos = positionForCell(r, c);
                cellEl.style.transition = `top 0.5s ${DROP_ANIMATION_EASING}, left 0.5s ${DROP_ANIMATION_EASING}, opacity 0.3s ease`;
                cellEl.style.top = finalPos.top + "px";
              }
            });
          });
        } else {
          droppedCells.forEach(({ oldRow, newRow, col, value }) => {
            const oldKey = `${oldRow},${col}`;
            const newKey = `${newRow},${col}`;
            let cellEl = cellElements.get(oldKey);

            if (cellEl) {
              animatingPositions.add(newKey);
              cellElements.delete(oldKey);
              cellEl.dataset.row = newRow; // Update dataset before map
              cellElements.set(newKey, cellEl);

              updateCellElementContent(cellEl, value);
              cellEl.style.background = getTileColor(value);
              cellEl.style.width = TILE_SIZE + "px";
              cellEl.style.height = TILE_SIZE + "px";
              cellEl.style.fontSize = `var(--tile-font-size)`;

              const newPos = positionForCell(newRow, col);
              cellEl.style.transition = `top ${DROP_ANIMATION_DURATION} ${DROP_ANIMATION_EASING}`;

              requestAnimationFrame(() => {
                cellEl.style.top = newPos.top + "px";
                cellEl.addEventListener("transitionend", () => animatingPositions.delete(newKey), { once: true });
              });
              processedDomKeys.add(newKey);
            } else {
              console.warn(`Dropped cell DOM element missing: ${oldKey}. Creating at ${newKey}.`);
              const val = board[newRow][col];
              if (val !== null) createStaticCell(newRow, col, val);
              processedDomKeys.add(newKey);
            }
          });

          newlyAddedCells.forEach(({ row, col, value }) => {
            const key = `${row},${col}`;
            if (processedDomKeys.has(key)) return;

            let cellEl = document.createElement("div");
            cellEl.classList.add("game-cell");
            cellEl.dataset.row = row;
            cellEl.dataset.col = col;

            updateCellElementContent(cellEl, value);
            cellEl.style.background = getTileColor(value);
            cellEl.style.width = TILE_SIZE + "px";
            cellEl.style.height = TILE_SIZE + "px";
            cellEl.style.fontSize = `var(--tile-font-size)`;

            const finalPos = positionForCell(row, col);
            // Start off-screen (above its column) and invisible
            cellEl.style.top = finalPos.top - TILE_SIZE * 1.2 + "px";
            cellEl.style.left = finalPos.left + "px";
            cellEl.style.opacity = "0";

            gameBoard.appendChild(cellEl); // Add to DOM when styled & positioned
            cellElements.set(key, cellEl);

            animatingPositions.add(key);
            // Synchronized top animation, separate opacity fade-in
            cellEl.style.transition = `top ${DROP_ANIMATION_DURATION} ${DROP_ANIMATION_EASING}, opacity 0.2s ease-in`;

            requestAnimationFrame(() => {
              cellEl.style.top = finalPos.top + "px";
              cellEl.style.opacity = "1";
              cellEl.addEventListener("transitionend", () => animatingPositions.delete(key), { once: true });
            });
            processedDomKeys.add(key);
          });

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const key = `${r},${c}`;
              const valueOnBoard = board[r][c];
              let cellEl = cellElements.get(key);

              if (valueOnBoard === null) {
                if (cellEl && !animatingPositions.has(key)) {
                  cellEl.remove();
                  cellElements.delete(key);
                }
              } else {
                if (!cellEl && !processedDomKeys.has(key)) {
                  console.warn(`Cell ${key} (value ${valueOnBoard}) missing. Creating statically.`);
                  createStaticCell(r, c, valueOnBoard);
                } else if (cellEl && !processedDomKeys.has(key) && !animatingPositions.has(key)) {
                  updateCellElementContent(cellEl, valueOnBoard);
                  cellEl.style.background = getTileColor(valueOnBoard);
                  cellEl.classList.remove("merging", "merged-highlight");
                  cellEl.style.opacity = "1";

                  if (key === mergeTargetKey) {
                    cellEl.classList.add("merged-highlight");
                    cellEl.addEventListener(
                      "animationend",
                      () => {
                        cellEl.classList.remove("merged-highlight");
                      },
                      { once: true },
                    );
                  }
                }
              }
            }
          }
        }
      }

      function isThreshold(length) {
        return chainThresholds.includes(length);
      }

      function animateChainMerge(chain, finalValue) {
        const finalCellPosition = chain[chain.length - 1];
        const finalKey = `${finalCellPosition.row},${finalCellPosition.col}`;

        for (let i = 0; i < chain.length - 1; i++) {
          const { row, col } = chain[i];
          const key = `${row},${col}`;
          const el = cellElements.get(key);
          if (el) {
            el.classList.add("merging");
          }
        }

        setTimeout(() => {
          for (let i = 0; i < chain.length - 1; i++) {
            const { row, col } = chain[i];
            const key = `${row},${col}`;
            const el = cellElements.get(key);
            if (el) {
              el.remove();
              cellElements.delete(key);
            }
            board[row][col] = null;
          }

          board[finalCellPosition.row][finalCellPosition.col] = finalValue;

          const droppedCellsInfo = applyGravity();
          const newlyAddedCellsInfo = refillBoard();

          renderBoard(false, droppedCellsInfo, newlyAddedCellsInfo, finalKey);
        }, 300);
      }

      function applyGravity() {
        // Logic remains robust
        const droppedCells = [];
        const newBoardState = Array.from({ length: rows }, () => Array(cols).fill(null));

        for (let c = 0; c < cols; c++) {
          const columnValues = [];
          for (let r = 0; r < rows; r++) {
            if (board[r][c] !== null) {
              columnValues.push({ value: board[r][c], originalRow: r });
            }
          }

          let newBoardWriteRow = rows - 1;
          for (let i = columnValues.length - 1; i >= 0; i--) {
            const cellData = columnValues[i];
            newBoardState[newBoardWriteRow][c] = cellData.value;
            if (cellData.originalRow !== newBoardWriteRow) {
              droppedCells.push({
                oldRow: cellData.originalRow,
                newRow: newBoardWriteRow,
                col: c,
                value: cellData.value,
              });
            }
            newBoardWriteRow--;
          }
        }
        board = newBoardState;
        return droppedCells;
      }

      // Make sure refillBoard uses the updated probability distribution
function refillBoard() {
  const newlyAddedCells = [];
  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < rows; r++) {
      if (board[r][c] === null) {
        // For refills, use mostly 2s and 4s (90% chance)
        let newValue;
        const rand = Math.random();
        if (rand < 0.6) {
          newValue = 2;
        } else if (rand < 0.9) {
          newValue = 4;
        } else {
          newValue = 8; // Only 10% chance for 8s
        }
        
        board[r][c] = newValue;
        newlyAddedCells.push({ row: r, col: c, value: newValue });
      }
    }
  }
  return newlyAddedCells;
}

      function processChain(chain) {
  if (chain.length < 2) return;
  
  let { row: startRow, col: startCol } = chain[0];
  let baseValue = board[startRow][startCol];
  
  // Verification logic
  for (let i = 1; i < chain.length; i++) {
    const { row, col } = chain[i];
    if (board[row][col] !== baseValue) {
      console.error("Invalid chain: non-identical values detected");
      return;
    }
  }

  // Count how many tiles of this value exist on the board
  const totalOfThisValue = countTilesOfValue(baseValue);
  const clearedAllOfValue = chain.length === totalOfThisValue;
  
  // Play merge sound
  if (SoundManager.isInitialized) {
    SoundManager.playMergeSound(chain.length);
  }
  
  // Add haptic feedback when merging tiles
  if (window.FarcadeSDK) {
    window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
  }
  
  // Final value and scoring remain the same
  let finalValue = baseValue * 2;
  score += baseValue * chain.length;
  
  // Check for "cleared all of this value" bonus
  if (clearedAllOfValue && chain.length >= 3) {
    movesLeft += 5; // Add 5 bonus moves
    showMoveBonus(0, false, true, baseValue); // Pass special flag for value clear
  }
  // Mini-rewards for new character achievements (16, 32, 64)
  else if ((finalValue === 16 || finalValue === 32 || finalValue === 64) && !achievedValues.has(finalValue)) {
    achievedValues.add(finalValue);
    movesLeft += 5; // Add 5 bonus moves
    showMoveBonus(finalValue); // Pass the value to customize the message
  }
  // Major milestone rewards (128, 256, 512, 4096)
  else if ((finalValue === 128 || finalValue === 256 || finalValue === 512 || finalValue === 4096) && finalValue > highestValue) {
    movesLeft += 25; // Add 25 bonus moves 
    showMoveBonus(finalValue); // Pass the value to customize the message
  }
  
  animateChainMerge(chain, finalValue);
  if (finalValue > highestValue) highestValue = finalValue;
  
  // Track that this value has been achieved
  achievedValues.add(finalValue);
}

// Helper function to count tiles of a specific value on the board
function countTilesOfValue(value) {
  let count = 0;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (board[r][c] === value) {
        count++;
      }
    }
  }
  return count;
}

// Update the showMoveBonus function to handle the value clear bonus
function showMoveBonus(value, isBoardClear = false, isValueClear = false, clearedValue = null) {
  const movesBox = document.querySelector('.moves-box');
  movesBox.classList.add('bonus-highlight');
  
  // Create a floating notification with milestone-specific text
  const notification = document.createElement('div');
  notification.className = 'bonus-notification';
  notification.style.display = 'flex';
  notification.style.alignItems = 'center';
  notification.style.justifyContent = 'center';
  notification.style.gap = '5px';
  
  // Customize message based on the milestone reached
  if (isValueClear && clearedValue !== null) {
    // Create first part of the text
    const textPart1 = document.createElement('span');
    textPart1.textContent = 'ALL ';
    notification.appendChild(textPart1);
    
    // Create and append the image
    const tileImg = document.createElement('img');
    tileImg.src = getPreloadedImageSrc(clearedValue);
    tileImg.alt = clearedValue.toString();
    tileImg.className = 'preview-img';
    notification.appendChild(tileImg);
    
    // Create second part of the text
    const textPart2 = document.createElement('span');
    textPart2.textContent = ' CLEARED! +5 MOVES!';
    notification.appendChild(textPart2);
    
    notification.style.background = 'rgba(255, 215, 0, 0.9)'; // Gold color for special achievement
  } else if (value === 16 || value === 32 || value === 64) {
    notification.textContent = 'NEW CHARACTER! +5 MOVES!';
  } else if (value === 128) {
    notification.textContent = 'NICE! +25 MOVES!';
  } else if (value === 256) {
    notification.textContent = 'AWESOME! +25 MOVES!';
  } else if (value === 512) {
    notification.textContent = 'MILESTONE! +25 MOVES!';
  } else if (value === 4096) {
    notification.textContent = 'AMAZING! +25 MOVES!';
  } else {
    notification.textContent = '+25 MOVES!';
  }

  // UPDATE: After reaching a milestone, show the next milestone target
  updateMilestonePreview();
  
  notification.style.position = 'absolute';
  notification.style.top = '50%';
  notification.style.left = '50%';
  notification.style.transform = 'translate(-50%, -50%)';
  notification.style.background = 'rgba(255, 255, 102, 0.9)';
  notification.style.color = '#000';
  notification.style.padding = '10px 20px';
  notification.style.borderRadius = '8px';
  notification.style.fontWeight = 'bold';
  notification.style.zIndex = '100';
  notification.style.animation = 'fadeInOut 1.5s forwards';
  gameBoard.appendChild(notification);
  
  // Add CSS animation if not already present
  if (!document.getElementById('bonus-animation-styles')) {
    const style = document.createElement('style');
    style.id = 'bonus-animation-styles';
    style.textContent = `
      @keyframes fadeInOut {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        80% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
      }
      .bonus-highlight {
        animation: pulse-green 0.8s ease-in-out;
      }
      @keyframes pulse-green {
        0% { background: rgba(0, 0, 0, 0.6); }
        50% { background: rgba(40, 230, 40, 0.8); }
        100% { background: rgba(0, 0, 0, 0.6); }
      }
    `;
    document.head.appendChild(style);
  }
  
  // Remove the notification after animation completes
  setTimeout(() => {
    notification.remove();
    movesBox.classList.remove('bonus-highlight');
  }, 1500);
}

function updateMilestonePreview() {
  // Define the milestone progression
  const milestones = [128, 512, 4096];
  
  // Find the next milestone based on current highest value
  let nextMilestone = milestones[0];
  for (const milestone of milestones) {
    if (highestValue < milestone) {
      nextMilestone = milestone;
      break;
    }
  }
  
  // If we've reached all milestones, use the last one
  if (highestValue >= milestones[milestones.length - 1]) {
    nextMilestone = milestones[milestones.length - 1];
  }
  
  // Clear and update the preview display
  previewDisplay.innerHTML = '';
  previewDisplay.style.visibility = "visible";
  
  // Add the text
  const textSpan = document.createElement('span');
  textSpan.textContent = "MAKE ";
  previewDisplay.appendChild(textSpan);
  
  // Add the tile image
  const milestoneImg = document.createElement('img');
  milestoneImg.src = getPreloadedImageSrc(nextMilestone);
  milestoneImg.alt = nextMilestone.toString();
  milestoneImg.className = 'preview-img';
  previewDisplay.appendChild(milestoneImg);
  
  // Add the bonus text
  const bonusSpan = document.createElement('span');
  bonusSpan.textContent = " FOR +25 MOVES";
  previewDisplay.appendChild(bonusSpan);
}

      function applyChainRules(cV, bV, iCL, iIM, newValue) {
  // Only allow identical values in a chain
  if (newValue === bV) {
    return {
      valid: true,
      cumulativeValue: bV * 2, // Result will be double the base value
      baseValue: bV,
      identicalChainLength: iCL + 1,
      initialIdenticalMet: true
    };
  }
  return { valid: false };
}

      function resetDrag() {
        // Logic remains robust
        isDragging = false;
        startCell = null;
        dragChain.forEach((cell) => {
          const key = `${cell.row},${cell.col}`;
          const el = cellElements.get(key);
          if (el) el.classList.remove("highlight");
        });
        dragChain = [];
        selectedCells.clear();
      }

      function resetPreview() {
  previewCumulativeValueState = null;
  previewBaseValue = null;
  previewIdenticalChainLengthState = 1;
  previewInitialIdenticalMet = false;
  
  // Instead of hiding, show milestone preview
  updateMilestonePreview();
}

      // Modify updatePreview function to use the milestone preview when not dragging
function updatePreview() {
  if (previewBaseValue !== null && dragChain.length >= 1) {
    // During active dragging, show the chain preview as before
    const resultValue = previewBaseValue * 2;
    
    // Clear previous content
    previewDisplay.innerHTML = '';
    previewDisplay.style.visibility = "visible";
    
    if (dragChain.length < 2) {
      // Need one more matching tile
      const textSpan = document.createElement('span');
      textSpan.textContent = "Need 1 more matching ";
      previewDisplay.appendChild(textSpan);
      
      const baseImg = document.createElement('img');
      baseImg.src = getPreloadedImageSrc(previewBaseValue);
      baseImg.alt = previewBaseValue.toString();
      baseImg.className = 'preview-img';
      previewDisplay.appendChild(baseImg);
    } else {
      // Show merge result (without the count)
      const baseImg = document.createElement('img');
      baseImg.src = getPreloadedImageSrc(previewBaseValue);
      baseImg.alt = previewBaseValue.toString();
      baseImg.className = 'preview-img';
      previewDisplay.appendChild(baseImg);
      
      const arrowSpan = document.createElement('span');
      arrowSpan.textContent = " â†’ ";
      previewDisplay.appendChild(arrowSpan);
      
      const resultImg = document.createElement('img');
      resultImg.src = getPreloadedImageSrc(resultValue);
      resultImg.alt = resultValue.toString();
      resultImg.className = 'preview-img';
      previewDisplay.appendChild(resultImg);
    }
  } else {
    // When not dragging, show milestone preview
    updateMilestonePreview();
  }
}

      function isValidMove(currentCell) {
        // Logic remains robust
        if (!startCell || !currentCell || dragChain.length === 0) return false;
        const lastCell = dragChain[dragChain.length - 1];
        if (!lastCell) return false;
        const { row: lastRow, col: lastCol } = lastCell;
        const { row: currentRow, col: currentCol } = currentCell;
        const cellKey = `${currentRow},${currentCol}`;
        if (selectedCells.has(cellKey)) return false;
        const isAdjacent =
          Math.abs(currentRow - lastRow) <= 1 &&
          Math.abs(currentCol - lastCol) <= 1 &&
          (currentRow !== lastRow || currentCol !== lastCol);
        const currentTileValue = board[currentRow][currentCol];
        const result = simulateAddTile(
          previewCumulativeValueState,
          previewBaseValue,
          previewIdenticalChainLengthState,
          previewInitialIdenticalMet,
          currentTileValue,
        );
        return isAdjacent && result.valid;
      }

      function simulateAddTile(cV, bV, iCL, iIM, newValue) {
  // First tile in chain
  if (bV === null) return { valid: true, cV: newValue, bV: newValue, iCL: 1, iIM: false };
  
  // Strict type comparison with Number conversion
  if (Number(newValue) === Number(bV)) {
    return { 
      valid: true, 
      cV: bV * 2, 
      bV: bV,
      iCL: iCL + 1, 
      iIM: true 
    };
  }
  
  return { valid: false };
}

      function handleStart(e) {
  if (!gameActive) return;

  // Initialize audio on first interaction
  if (!SoundManager.isInitialized) {
    SoundManager.init();
    // Unlock iOS audio restrictions by playing a silent sound within the user gesture
    const silentBuffer = SoundManager.audioContext.createBuffer(1, 1, 22050);
    const silentSource = SoundManager.audioContext.createBufferSource();
    silentSource.buffer = silentBuffer;
    silentSource.connect(SoundManager.audioContext.destination);
    silentSource.start(0);
    
    // Also force resume the audio context (iOS requirement)
    SoundManager.audioContext.resume();
  }
  
  let target = e.target;
  if (target.tagName === "IMG") target = target.parentElement;
  const cell = target.closest(".game-cell");
  if (!cell) return;
  const position = getCellPosition(cell);
  if (!position) return;
  
  isDragging = true;
  startCell = position;
  const startValue = board[position.row][position.col];
  previewCumulativeValueState = startValue;
  previewBaseValue = startValue;
  previewIdenticalChainLengthState = 1;
  previewInitialIdenticalMet = false;
  dragChain = [position];
  const key = `${position.row},${position.col}`;
  selectedCells.clear();
  selectedCells.add(key);
  const startEl = cellElements.get(key);
  if (startEl) startEl.classList.add("highlight");
  
  // Play sound on first tile selection - critical for iOS audio
  SoundManager.playBubbleSound(1);
  
  // Add haptic feedback on first tile selection
  if (window.FarcadeSDK) {
    window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
  }
  
  updatePreview();
}

      function recalculatePreviewValues() {
        // Logic remains robust
        previewCumulativeValueState = null;
        previewBaseValue = null;
        previewIdenticalChainLengthState = 1;
        previewInitialIdenticalMet = false;
        for (let i = 0; i < dragChain.length; i++) {
          const { row, col } = dragChain[i];
          const tileValue = board[row][col];
          const result = simulateAddTile(
            previewCumulativeValueState,
            previewBaseValue,
            previewIdenticalChainLengthState,
            previewInitialIdenticalMet,
            tileValue,
          );
          if (result.valid) {
            previewCumulativeValueState = result.cV;
            previewBaseValue = result.bV;
            previewIdenticalChainLengthState = result.iCL;
            previewInitialIdenticalMet = result.iIM;
          } else {
            console.error("Error recalculating preview");
            break;
          }
        }
      }

      function handleMove(e) {
  if (!isDragging || !gameActive || dragChain.length === 0) return;
  
  let target = e.target;
  if (target.tagName === "IMG") target = target.parentElement;
  
  // Get the cell or find the nearest cell using coordinates for better diagonal handling
  let cell = target.closest(".game-cell");
  if (!cell && e.clientX && e.clientY) {
    // Find the nearest cell by coordinates for diagonal movements
    cell = findNearestCellForDiagonal(e.clientX, e.clientY);
  }
  
  if (!cell) return;
  const currentCell = getCellPosition(cell);
  if (!currentCell) return;
  
  const cellKey = `${currentCell.row},${currentCell.col}`;
  
  // Handle going backwards in the chain (unchanged)
  if (dragChain.length > 1) {
    const secondLastCell = dragChain[dragChain.length - 2];
    if (secondLastCell.row === currentCell.row && secondLastCell.col === currentCell.col) {
      const lastCellPopped = dragChain.pop();
      const lastCellKey = `${lastCellPopped.row},${lastCellPopped.col}`;
      selectedCells.delete(lastCellKey);
      const lastEl = cellElements.get(lastCellKey);
      if (lastEl) lastEl.classList.remove("highlight");
      recalculatePreviewValues();
      updatePreview();
      return;
    }
  }
  
  // If already selected, just return
  if (selectedCells.has(cellKey)) return;
  
  // The rest remains unchanged
  if (isValidMove(currentCell)) {
    const simResult = simulateAddTile(
      previewCumulativeValueState,
      previewBaseValue,
      previewIdenticalChainLengthState,
      previewInitialIdenticalMet,
      board[currentCell.row][currentCell.col],
    );
    if (simResult.valid) {
      // Existing code for valid moves...
      previewCumulativeValueState = simResult.cV;
      previewBaseValue = simResult.bV;
      previewIdenticalChainLengthState = simResult.iCL;
      previewInitialIdenticalMet = simResult.iIM;
      dragChain.push(currentCell);
      selectedCells.add(cellKey);
      const el = cellElements.get(cellKey);
      if (el) el.classList.add("highlight");

      // Initialize audio on first interaction if needed
      if (!SoundManager.isInitialized) {
        SoundManager.init();
      }
      // Play bubble sound with pitch based on chain length
      SoundManager.playBubbleSound(dragChain.length);
      
      // Add haptic feedback when adding to chain
      if (window.FarcadeSDK) {
        window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
      }
      
      updatePreview();
    }
  }
}

// New helper function to find the nearest valid cell for diagonal movement
function findNearestCellForDiagonal(clientX, clientY) {
  // Convert client coordinates to board-relative coordinates
  const boardRect = gameBoard.getBoundingClientRect();
  const boardX = clientX - boardRect.left;
  const boardY = clientY - boardRect.top;
  
  // If we have a last cell in the chain, prioritize diagonal movement
  if (dragChain.length > 0) {
    const lastCell = dragChain[dragChain.length - 1];
    const lastCellKey = `${lastCell.row},${lastCell.col}`;
    const lastCellEl = cellElements.get(lastCellKey);
    
    if (lastCellEl) {
      const lastRect = lastCellEl.getBoundingClientRect();
      
      // Find all potential diagonal cells from the last selected cell
      for (let r = Math.max(0, lastCell.row - 1); r <= Math.min(rows - 1, lastCell.row + 1); r++) {
        for (let c = Math.max(0, lastCell.col - 1); c <= Math.min(cols - 1, lastCell.col + 1); c++) {
          // Skip if it's the same cell or non-diagonal adjacent cell
          if ((r === lastCell.row && c === lastCell.col) || 
              (r === lastCell.row && Math.abs(c - lastCell.col) === 1) || 
              (c === lastCell.col && Math.abs(r - lastCell.row) === 1)) {
            continue;
          }
          
          // Check if this diagonal cell is valid for the next move
          const diagonalCell = {row: r, col: c};
          if (isValidMove(diagonalCell)) {
            const key = `${r},${c}`;
            const el = cellElements.get(key);
            if (el) {
              const rect = el.getBoundingClientRect();
              
              // Check if pointer is near the cell (with extended buffer for diagonals)
              const centerX = rect.left + rect.width / 2 - boardRect.left;
              const centerY = rect.top + rect.height / 2 - boardRect.top;
              const distance = Math.sqrt(Math.pow(boardX - centerX, 2) + Math.pow(boardY - centerY, 2));
              
              // If within a more generous radius (60% of tile size), consider it a hit
              if (distance < TILE_SIZE * 0.6) {
                return el;
              }
            }
          }
        }
      }
    }
  }

  // Fallback to standard cell finding logic if no diagonal match
  let closestCell = null;
  let closestDistance = Infinity;
  
  // Iterate through all cell elements
  cellElements.forEach((el, key) => {
    const rect = el.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2 - boardRect.left;
    const centerY = rect.top + rect.height / 2 - boardRect.top;
    const distance = Math.sqrt(Math.pow(boardX - centerX, 2) + Math.pow(boardY - centerY, 2));
    
    // Use a standard hit radius
    if (distance < TILE_SIZE * 0.5 && distance < closestDistance) {
      closestCell = el;
      closestDistance = distance;
    }
  });
  
  return closestCell;
}

      function handleEnd() {
  if (!gameActive) return;
  if (isDragging && dragChain.length >= 2) {
    // Process the chain first, which will queue up animations and bonuses
    processChain(dragChain);
    
    // Decrement moves AFTER processing the chain
    movesLeft--;
    
    // Check moves state after a slight delay to ensure
    // any bonus moves have been applied
    setTimeout(() => {
      if (movesLeft <= 0) {
        gameActive = false;
        console.log("GAME OVER - Score: " + score + ", Highest value: " + highestValue);
        
        // No "Out of Moves!" message, just delay the Farcade game over call slightly
        setTimeout(() => {
          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: score });
          }
        }, 500); // Brief delay to ensure animations complete
      } 
      else if (movesLeft === 5) {
        // Show warning message at exactly 5 moves left
        showLowMovesWarning();
      }
    }, 350); // Slightly longer than the chain merge animation
  }
  resetDrag();
  resetPreview();
}

// Function to show warning message at 5 moves left
function showLowMovesWarning() {
  const notification = document.createElement('div');
  notification.className = 'moves-warning-notification';
  notification.textContent = '5 MOVES LEFT!';
  
  notification.style.position = 'absolute';
  notification.style.top = '50%';
  notification.style.left = '50%';
  notification.style.transform = 'translate(-50%, -50%)';
  notification.style.background = 'rgba(255, 215, 0, 0.9)'; // Gold color for warning
  notification.style.color = 'black';
  notification.style.padding = '12px 25px';
  notification.style.borderRadius = '8px';
  notification.style.fontWeight = 'bold';
  notification.style.fontSize = '22px';
  notification.style.zIndex = '100';
  notification.style.animation = 'fadeInWarning 2s forwards';
  gameBoard.appendChild(notification);
  
  // Add CSS animation if not already present
  if (!document.getElementById('warning-animation-styles')) {
    const style = document.createElement('style');
    style.id = 'warning-animation-styles';
    style.textContent = `
      @keyframes fadeInWarning {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
      }
    `;
    document.head.appendChild(style);
  }
  
  // Add haptic feedback for the warning
  if (window.FarcadeSDK) {
    window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
  }
  
  // Remove the notification after animation completes
  setTimeout(() => {
    notification.remove();
  }, 2000);
}

      function getCellPosition(element) {
        // Logic remains robust
        if (!element || !element.dataset) return null;
        const row = parseInt(element.dataset.row, 10);
        const col = parseInt(element.dataset.col, 10);
        if (isNaN(row) || isNaN(col)) return null;
        return { row, col };
      }

      // Event Listeners
      gameBoard.addEventListener("mousedown", handleStart);
      gameBoard.addEventListener("mousemove", handleMove);
      window.addEventListener("mouseup", handleEnd);
      gameBoard.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length > 0) {
            handleStart(e.touches[0]);
            e.preventDefault();
          }
        },
        { passive: false },
      );
      gameBoard.addEventListener(
  "touchmove",
  (e) => {
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      const elementAtPoint = document.elementFromPoint(touch.clientX, touch.clientY);
      handleMove({ 
        target: elementAtPoint,
        clientX: touch.clientX,
        clientY: touch.clientY
      }); // Enhanced synthetic event with coordinates
      e.preventDefault();
    }
  },
  { passive: false },
);
      window.addEventListener("touchend", (e) => {
        if (isDragging) {
          handleEnd();
        }
      });
      document.addEventListener("contextmenu", (e) => {
        if (e.target.closest("#game-board")) e.preventDefault();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "r" || e.key === "R") restartGame();
      });

      function restartGame() {
  // Logic remains robust
  movesLeft = 25;
  gameActive = true;
  highestValue = 0;
  score = 0;
  achievedValues.clear(); // Reset the achievements
  initGameLogic(); // Call the renamed init function
  
  // Explicitly update the milestone preview after game restart
  updateMilestonePreview();
}

      // Start the game after images are preloaded
      preloadAllImages()
        .then(() => {
          console.log("All images preloaded successfully.");
          initGameLogic();
          updateMilestonePreview(); // Initialize the milestone preview

          // Signal to Farcade that the game is ready
          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.ready();
          }
        })
        .catch((error) => {
          console.error("Failed to preload images. Game cannot start.", error);
          // Handle error appropriately, e.g., show a message to the user
          alert("Error loading game assets. Please try refreshing the page.");
        });
    </script>
  </body>
</html>